# complete-img-file-processing
Complete, exhaustive, multifunction image file processing and transformation app.

Initial requirements and specs draft 2025-11-05.

I need an image file processing application. The intent is to utilize this application for both personal home family photo album images and commercially available images for sale on e-commerce websites.
This project, thread, chat has the ID/label: "Image Processing App 2025-11-04".

The high-level requirements are as follows. I need complete grammar and spell checking on all output data across the board. I need all output data formatted in proper English sentence structure, including capitalization as appropriate. I need all output CSV files to have an initial/first column containing an application-generated primary key. I need all the output CSV files to have an ending/final column containing the datetime stamp of data acquisition/data row creation.

The application executable accepts a parameter on the command line by name, not by position, which contains a comma-delimited string of Windows-style, i.e., backslash, path names that the application will use as the 'source roots'. These are the directories where the application will start scanning for image files. This is a required parameter. There is no default value for this parameter. Minimum quantity of required paths = 1. Maximum number of paths accepted = 10. The application will validate this input for format and syntax, plus that each path supplied truly exists. If the path does not exist, this application will not create it. If there are errors or exceptions, the application will send these to the Console as Warning-level messages and to the log file as Warning-level messages. This will not be a fatal error and will not halt processing. If a path does not exist, then the application will skip that path.

The application executable accepts a parameter on the command line by name, not by position, which contains a comma-delimited string of Windows-style, i.e., backslash, path names that the application uses as the 'output roots'. These are the directories where the application will store the images for post-processing. This is a required parameter. There is no default value for this parameter. Minimum quantity of required paths = 1. Maximum number of paths accepted = 1. The application will validate this input for format and syntax, plus that each path supplied truly exists. If the path does not exist, this application will create a new path. If there are errors or exceptions, the application will send these to the Console as Warning-level messages and to the log file as Warning-level messages. This will not be a fatal error and will not halt processing. If a path does not exist, then the application will create that path and log the action.

The application executable accepts a parameter on the command line by name, not by position, that contains a comma-delimited string of Windows-style, i.e., backslash, path names that will be used as the "admin output" for the functionality to store the CSV files, log files, and any other non-image files the application generates during processing. This is a required parameter. There is no default value for this parameter. Minimum quantity of required paths = 
1. Maximum quantity of paths accepted = 1. The application will validate this input for format and syntax, plus that each path supplied truly exists. If the path does not exist, this application will create a new path. If there are errors or exceptions, the application will send these to the Console as Warning-level messages and to the log file as Warning-level messages. This will not be a fatal error and will not halt processing. If a path does not exist, then the application will create that path and log the action.

The application executable accepts a parameter on the command line by name, not by position, that contains an integer number as a menu item, which I call out in detail in subsequent paragraphs as the 'processing functionality option' for the application to understand which image file processing functionality the user wants the application to execute, as detailed in subsequent paragraphs. This is a required parameter. The default value for this parameter = 1. The value of '1' is equivalent to executing all or the entire suite of functionality. Minimum quantity of required integers = 1. Maximum number of integers accepted = 1. The application will validate this input for format and syntax. If the integer (menu selection) is invalid or does not exist, then the application logs this information, and the application halts and closes gracefully. If there are errors or exceptions, such as a file not being found or a directory not being accessible, the application sends these to the Console as Warning-level messages and to the log file as Warning-level messages. This will not be a fatal error and will not halt processing unless the application cannot find the integer/menu item within the application.
Beginning at the source root(s), the application will recursively scan the directory and all subdirectories for all image files.

Menu Item 1 [default]: Execute all functionality as detailed below.

Menu Item 2: I need all the image files within the source root(s) folder assessed and evaluated for focus quality, sharpness, and blurriness. I need the application to identify images that are dramatically, human-noticeably blurry to a great degree. Minimally, this functionality requires one AI image processing model, but I prefer more and varied models without going overboard. Additionally, the application will give greater weight to the center/middle area of the image than the peripheral areas, as this is common in photography to focus on the center/main image, and let the stereoscopic and 3D depth dimension be fuzzy. Utilizing the best option(s) and best practices, assess, evaluate, and extract from each image file the necessary data to perform the calculations and statistical analysis, then record everything in a CSV file with one row for each image file and columns/fields for each model, calculation, and decision. Then aggregate and synthesize all the separate models/decisions into a single Pass/Fail or Blurry TRUE/FALSE field/column. Store all the data in a CSV file in the specified admin output folder location. You will normalize and make consistent all the fields/columns in the file. Add an initial/first field/column and generate a Sequence Number or Primary Key-like integer for the application to populate that field with. If no data is available for a specific image file and field, then leave that cell empty/blank. The CSV output file naming convention is: "All_Image_Files_Focus_" & suffixed with the current local datetime stamp in the format: "yyyy-mm-dd_HH-mm-ss" with the time in 24-hour time format & then complete the name with the usual file extension. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file. Lastly, the application should move these blurry image files, not copy but move, to a different/new top-level folder. While the application maintains and creates, as necessary, the original folder structure, the top-level folder should be "IMGOrig-Blurry,” and the application should locate/find/build at the same level and on the same drive as the source root. The application renames all blurry image files to prepend "BLUR_ORIG_" to the beginning of the existing file name, and the remainder of the existing file name remains.

Menu Item 3: Extract all image file properties, attributes, security descriptors, EXIF metadata, and other metadata. Store all the data in a CSV file in the specified admin output folder location. You will normalize and make consistent all the fields/columns in the file. Add an initial/first field/column and generate a Sequence Number or Primary Key-like integer for the application to populate that field with. If no data is available for a specific image file and field, then leave that cell empty/blank. The application groups all date fields/columns together and sequences them one after the other. Dates are in the ISO standard format. Times are in 24-hour and ISO standard format. Times, when there is an option or choice, should all be local time based upon the image GPS data. The application outputs GPS data in a minimum of two different formats: DMS format and decimal format. I need the application to extract/calculate additional data fields and store this extra data, too: 1) Current image orientation: Portrait, Landscape, or Square, 2) the image's Aspect Ratio common/standard/nominal name/label, 3) the best/minimum/earliest datetime out of all the datetime fields to represent the actual image capture datetime, 4) the meteorological season of the image capture datetime, 5) the astronomical season of the image capture datetime, 6) the calendar quarter of the image capture datetime, 7) the standard time of day moniker/label for the time of day of the image capture datetime, 8) the US/European/English Astrological sign/house under which the image capture datetime falls, 9) the common/standard decade label/moniker for the nominal decade under which the image capture datetime falls, and 10) the Chinese Astrological Year of the xxx, under which the image capture datetime falls. Since the output file is a CSV file, the application converts any commas within the data that it extracts to semicolons. The application needs to strip out any line breaks, new lines, and CRLFs embedded within the data so that the application can store and present the data as single rows/lines within the CSV file. The CSV output file naming convention is: "All_Image_Files_Metadata_" & suffixed with the current local datetime stamp in the format: "yyyy-mm-dd_HH-mm-ss" with the time in 24-hour time format & then complete the name with the usual file extension. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file.

Menu Item 4: Utilizing the best option(s) and best practices, assess, evaluate, and extract from each image file a primary Caption, two alternate Captions, a primary verbose Description, two alternate verbose Descriptions, a minimum of one keyword to a maximum of 25 keywords, a minimum of one tag/hashtag to a maximum of 25 tags/hashtags, and an Alt Text blurb meeting the Alt Test specifications. Minimally, this functionality requires one AI image processing model, but I prefer more and varied models without going overboard. Store all the data in a CSV file in the specified admin output folder location. You will normalize and make consistent all the fields/columns in the file. Add an initial/first field/column and generate a Sequence Number or Primary Key-like integer for the application to populate that field with. If no data is available for a specific image file and field, then leave that cell empty/blank. The application groups all date fields/columns together and sequences them one after the other. Dates are in the ISO standard format. Times are in 24-hour and ISO standard format. Times, when there is an option or choice, should all be local time based upon the image GPS data. GPS or location data should be in human-readable form. Since the output file is a CSV file, the application will convert any commas within the data that it extracts or generates into semicolons. The application needs to strip out any line breaks, new lines, and CRLFs embedded within the data so that the application can store and present the data as single rows/lines within the CSV file. The CSV output file naming convention is: "All_Image_Files_Captions_" & suffixed with the current local datetime stamp in the format: "yyyy-mm-dd_HH-mm-ss" with the time in 24-hour time format & then complete the name with the usual file extension. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file. I need the application to generate additional column(s) and additional data for the GPS location data in a human-readable English language format. The location data should minimally include: 1) N-S hemisphere, 2) E-W hemisphere, 3) Continent, 4) Country, 5) Region, where available, 6) State or Province, 7) City or District, 8) Local Region, District, or Neighborhood, where available, and 9) ISO tags/designators if available for each of the preceding pieces of data.

Menu Item 5: Utilizing the best option(s) and best practices, assess, evaluate, and extract from each image file the predominant/dominant color(s); a total of four colors. For each majority color list: 1) The RGB values and HEX value for what was detected/calculated/determined, 2) list the percentage within the image, 3) list the HSV-A values for the same, 4) the nearest matching color with an English language human-readable name, 5) the source of that name, 6) if doable, the CMYK values, 7) if doable, any ISO color name, if one exists, and 8) any other global/international/standard color names/labels. Minimally, this functionality requires one AI image processing model, but I prefer more and varied models without going overboard. Store all the data in a CSV file in the specified admin output folder location. You will normalize and make consistent all the fields/columns in the file. Add an initial/first field/column and generate a Sequence Number or Primary Key-like integer for the application to populate that field with. If no data is available for a specific image file and field, then leave that cell empty/blank. Since the output file is a CSV file, the application will convert any commas within the data that it extracts or generates into semicolons. The application needs to strip out any line breaks, new lines, and CRLFs embedded within the data so that the application can store and present the data as single rows/lines within the CSV file. The CSV output file naming convention is: "All_Image_Files_Colors_" & suffixed with the current local datetime stamp in the format: "yyyy-mm-dd_HH-mm-ss" with the time in 24-hour time format & then complete the name with the usual file extension. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file.

Menu item 6: I need the application to save a copy of all original image files (which I anticipate are all in color) without any processing to the output root location under a folder with the name "CLR_ORIG" and the application maintains the source root folder structure under that top-level folder. The application renames all image files to prepend "CLR_ORIG_" to the beginning of the existing file name, and the remainder of the existing file name remains. If a folder does not exist, then the application creates that folder. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file.

Menu Item 7: I need the application to modify and transform a copy of all original image files (which I anticipate are all in color) into Black and White (grayscale) and then save to the output root location under a folder with the name "BWG_ORIG" and the application maintains the source root folder structure under that top-level folder. The application renames all image files to prepend "BWG_ORIG_" to the beginning of the existing file name, and the remainder of the existing file name remains. If a folder does not exist, then the application creates that folder. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file.

Menu Item 8: I need the application to modify and transform a copy of all original image files (which I anticipate are all in color) into Sepia-toned and then save to the output root location under a folder with the name "SEP_ORIG" and the application maintains the source root folder structure under that top-level folder. The application renames all image files to prepend "SEP_ORIG_" to the beginning of the existing file name, and the remainder of the existing file name remains. If a folder does not exist, then the application creates that folder. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file.

Menu Item 9: I need the application to modify and transform a copy of all original image files (which I anticipate are all in color) into a Pencil Sketch utilizing a broad pencil tip, a large radius for processing, high clarity, low blurring, and medium strength for processing, and then save to the output root location under a folder with the name "PSK_ORIG" and the application maintains the source root folder structure under that top-level folder. The application renames all image files to prepend "PSK_ORIG_" to the beginning of the existing file name, and the remainder of the existing file name remains. If a folder does not exist, then the application creates that folder. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file.

Menu Item 10: I need the application to modify and transform a copy of all original image files (which I anticipate are all in color) into a strong outline-type image suitable for inclusion in a coloring book. You need to research and attempt to find some reasonable specifications for coloring book images, and apply those optimal and best practice coloring book settings/configs as internal defaults that will not generally require user modification, and then save the transformed image to the output root location under a folder with the name "BK_Coloring" and the application maintains the source root folder structure under that top-level folder. The application renames all image files to prepend "BK_Coloring_" to the beginning of the existing file name, and the remainder of the existing file name remains. If a folder does not exist, then the application creates that folder. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file.

Menu Item 11: I need the application to modify and transform a copy of all original image files (which I anticipate are all in color) into a connect-the-dots-style image suitable for inclusion in a connect-the-dots activity book. You need to research and attempt to find some reasonable specifications for connect-the-dots book images, and apply those optimal and best practice connect-the-dots book settings/configs as internal defaults that will not generally require user modification, and then save the transformed image to the output root location under a folder with the name "BK_CTD" and the application maintains the source root folder structure under that top-level folder. The application renames all image files to prepend "BK_CTD_" to the beginning of the existing file name, and the remainder of the existing file name remains. If a folder does not exist, then the application creates that folder. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file. You need to implement additional settings for this functionality that the user can tweak. The application will not integrate these into the command line. The application will store these in a settings file with the application. The additional settings are at a minimum: 1) Maximum Dots Allowed Per Image, 2) Minimum Distance Between Dots, 3) Minimum Distance Between Dots UOM, 4) Maximum Distance Between Dots, 5) Maximum Distance Between Dots UOM, 6) Maximum Dot Size, 7) Maximum Dot Size UOM, 8) Minimum Dot Size, and 9) Minimum Dot Size UOM. You need to research and perform statistical analysis for the optimal values to set these to initially, and set the initial values accordingly.

Menu Item 12: I need the application to modify and transform a copy of all original image files (which I anticipate are all in color) into a color-by-numbers-style image suitable for inclusion in a color-by-numbers activity book. You need to research and attempt to find some reasonable specifications for color-by-numbers book images, and apply those optimal and best practice color-by-numbers book settings/configs as internal defaults that will not generally require user modification, and then save the transformed image to the output root location under a folder with the name "BK_CBN" and the application maintains the source root folder structure under that top-level folder. The application renames all image files to prepend "BK_CBN_" to the beginning of the existing file name, and the remainder of the existing file name remains. If a folder does not exist, then the application creates that folder. When saving the file, if the specified file name already exists, then do not overwrite the existing file; append a sequence number to the file name and save the file. You need to implement additional settings for this functionality that the user can tweak. The application will not integrate these into the command line. The application will store these in a settings file with the application. The additional settings are at a minimum: 1) Maximum Distinct Colors Allowed Per Image, 2) Minimum Distance Between Distinct Color Groupings, 3) Maximum Distance Between Distinct Color Groupings, and 4) Minimum Area Size for Distinct Color Groupings. In real life, as one example, there may be hundreds of shades/hues of what someone may call "Orange" color, but I do not need each shade called out and numbered for this implementation. I need similar shades/hues grouped into one nominal color and given a single number. Additionally, you need to implement some amount of normalization/smoothing/blurring so that an area that is a distinct color, but the size of the area is below some threshold, then it does not get called out separately, but gets engulfed/consumed by the more dominant/surrounding color. You need to research and perform statistical analysis for the optimal values to set these configs initially, and set the initial values accordingly. Then, the resulting image transformation should have the colors removed and numbers overlayed, and probably maintain a light outline of the entire image.

Across all processing, the application needs to send "still processing" or "still alive" info-level messages to the console and to the log file with indications of progress and status.

Moreover, I need the application to be self-aware and self-monitoring during processing operations. I need the application to take samples and perform statistical analysis of what it is producing for output. Check image files that have undergone processing or transformation, perform minimal QA/QC checks, quick checks, and confirm actual against statistically expected results, i.e., output file size: smaller than anticipated or larger than expected, processing/transformation execution time/duration: faster than expected or slower than anticipated, empty or near empty files, compare hash values for original file against processed file to look for duplicate files – which should not be the case, and other checks/metrics you can think of.

Before you begin, you need to analyze all these requirements and specifications and let me know if they are complete, concise, programmable, feasible, doable, unambiguous, consistent, self-consistent, in line with best practices, clear, and understandable. You need to let me know of any potential issues, gaps, missing pieces/parts, and any nice-to-haves. You need to create an implementation that is as cost-effective as possible, free is best, and low-cost is next best. I am willing to make compromises to include quality to keep the cost as low as possible. Processing resources and processing time are of little concern to me, although the maximum reasonable processing time is approximately two days for processing roughly 27,000 images.

My local PC system is as follows:
Device name	PlatoPC
Processor	12th Gen Intel(R) Core (TM) i7-12650H (2.70 GHz)
Installed RAM	64.0 GB (63.7 GB usable)
System type: 64-bit operating system, x64-based processor
Edition	Windows 11 Pro Version	25H2
OS build	26200.7019
Experience	Windows Feature Experience Pack 1000.26100.265.0
Visual Studio and Visual Studio Code are installed at the latest community versions.
Python 3.14.0
Other programming languages are installed.
Multiple databases and database engines are installed.



